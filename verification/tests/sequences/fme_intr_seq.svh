// Copyright 2021 Intel Corporation
// SPDX-License-Identifier: MIT

//-----------------------------------------------------------------------------
// Description : 
// class fme_intr_seq.svh is executed by fme_intr_test .
// This sequnce verifies the functionality of FME error interrupts  
// The interrupt is generated by forcing/ writing the error register .
// PBA mechanism is verified using masking and un-masking the interrupt vector
// Sequence is running on virtual_sequencer  
//-----------------------------------------------------------------------------

`ifndef FME_INTR_SEQ_SVH
`define FME_INTR_SEQ_SVH

class fme_intr_seq extends base_seq;
    `uvm_object_utils(fme_intr_seq)

    rand bit [63:0] int_start_addr;
    rand bit [31:0] wr_data;
    bit      [63:0] rd_data;
    uvm_status_e status;

    constraint int_start_addr_c {
        int_start_addr[7:0] == 0;
	int_start_addr[63:32] == 0;
    }

    function new(string name = "fme_intr_seq");
        super.new(name);
    endfunction : new

    task body();

        super.body();
	program_msix_table();
	#200ns;
	inj_err();
        #10us;
	check_pba(6);
	#200ns;
	clear_mask();
	#2us;
	check_wr_data(64'hbeef_0060, 32'hdead_0060);

    endtask : body

    virtual task program_msix_table();

	force tb_top.DUT.pcie_wrapper.genblk1[1].msix_csr.cr2out_msix_addr0 = 64'hbeef_0000;
	force tb_top.DUT.pcie_wrapper.genblk1[1].msix_csr.cr2out_msix_addr1 = 64'hbeef_0000 + 'h10;
	force tb_top.DUT.pcie_wrapper.genblk1[1].msix_csr.cr2out_msix_addr2 = 64'hbeef_0000 + 'h20;
	force tb_top.DUT.pcie_wrapper.genblk1[1].msix_csr.cr2out_msix_addr3 = 64'hbeef_0000 + 'h30;
	force tb_top.DUT.pcie_wrapper.genblk1[1].msix_csr.cr2out_msix_addr4 = 64'hbeef_0000 + 'h40;
	force tb_top.DUT.pcie_wrapper.genblk1[1].msix_csr.cr2out_msix_addr5 = 64'hbeef_0000 + 'h50;
	force tb_top.DUT.pcie_wrapper.genblk1[1].msix_csr.cr2out_msix_addr6 = 64'hbeef_0000 + 'h60;

	force tb_top.DUT.pcie_wrapper.genblk1[1].msix_csr.cr2out_msix_ctldat0[31:0] = 32'hdead_0000;
	force tb_top.DUT.pcie_wrapper.genblk1[1].msix_csr.cr2out_msix_ctldat1[31:0] = 32'hdead_0000+'h10;
	force tb_top.DUT.pcie_wrapper.genblk1[1].msix_csr.cr2out_msix_ctldat2[31:0] = 32'hdead_0000+'h20;
	force tb_top.DUT.pcie_wrapper.genblk1[1].msix_csr.cr2out_msix_ctldat3[31:0] = 32'hdead_0000+'h30;
	force tb_top.DUT.pcie_wrapper.genblk1[1].msix_csr.cr2out_msix_ctldat4[31:0] = 32'hdead_0000+'h40;
	force tb_top.DUT.pcie_wrapper.genblk1[1].msix_csr.cr2out_msix_ctldat5[31:0] = 32'hdead_0000+'h50;
	force tb_top.DUT.pcie_wrapper.genblk1[1].msix_csr.cr2out_msix_ctldat6[31:0] = 32'hdead_0000+'h60;
    endtask : program_msix_table

    virtual task inj_err();
	tb_env0.regs.fme_regs.RAS_ERROR_INJ.write(status, 64'h4);
    endtask : inj_err

    virtual task check_pba(int pba_bit);
	if(!tb_top.DUT.pcie_wrapper.genblk1[1].msix_csr.cr2out_msix_pba[pba_bit])
	    `uvm_error(get_name(), $psprintf("PBA bit is not asserted!"))
    endtask : check_pba

    virtual task clear_mask();
	force tb_top.DUT.pcie_wrapper.genblk1[1].msix_csr.cr2out_msix_ctldat6[63:32] = 32'h0;
    endtask : clear_mask

    virtual task check_wr_data(bit [63:0] addr, bit [31:0] exp_data);
    bit [31:0] host_intr_rdata[16];
    bit[63:0]    addr;
    host_mem_read( .addr_(addr) , .data_(host_intr_rdata) , .len('d16) );
    if(changeEndian(host_intr_rdata[0]) !== exp_data)
              `uvm_error(get_name(), $psprintf("Interrupt write data mismatch exp = %0h act = %0h", exp_data, changeEndian(host_intr_rdata[0])))
    endtask : check_wr_data

endclass : fme_intr_seq

`endif // FME_INTR_SEQ_SVH
