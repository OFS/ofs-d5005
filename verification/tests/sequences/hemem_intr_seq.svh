// Copyright 2021 Intel Corporation
// SPDX-License-Identifier: MIT

//-----------------------------------------------------------------------------
// Description : 
// class hemem_intr_seq.svh is executed by hemem_intr_test 
// This sequence verifies the functionality of HE_MEM interrputs  
// The interrupt is generated by forcing/ writing the error register 
// PBA mechanism is verified using masking and un-masking the interrupt vector
// Sequence is running on virtual_sequencer .
//-----------------------------------------------------------------------------

`ifndef HEMEM_INTR_SEQ_SVH
`define HEMEM_INTR_SEQ_SVH

class hemem_intr_seq extends he_mem_lpbk_seq;
    `uvm_object_utils(hemem_intr_seq)

    rand int idx;
    rand int vec_num;

    constraint idx_c { soft idx == 3; }
    constraint vec_num_c { soft vec_num inside {[0:3]}; }

    function new(string name = "hemem_intr_seq");
        super.new(name);
    endfunction : new

    task body();
        super.body();
        check_pba();
        clear_mask();
	#2us;
	check_wr_data(64'hbeef_0000+(vec_num*'h10), 32'hdead_0000+(vec_num*'h10));
    endtask : body

    virtual task additional_csr_program();
        program_msix_table();
	inj_err();
    endtask : additional_csr_program

    virtual task program_msix_table();
	
	force tb_top.DUT.pcie_wrapper.genblk1[3].msix_csr.cr2out_msix_addr0 = 64'hbeef_0000;
	force tb_top.DUT.pcie_wrapper.genblk1[3].msix_csr.cr2out_msix_addr1 = 64'hbeef_0000 + 'h10;
	force tb_top.DUT.pcie_wrapper.genblk1[3].msix_csr.cr2out_msix_addr2 = 64'hbeef_0000 + 'h20;
	force tb_top.DUT.pcie_wrapper.genblk1[3].msix_csr.cr2out_msix_addr3 = 64'hbeef_0000 + 'h30;
	force tb_top.DUT.pcie_wrapper.genblk1[3].msix_csr.cr2out_msix_addr4 = 64'hbeef_0000 + 'h40;
	force tb_top.DUT.pcie_wrapper.genblk1[3].msix_csr.cr2out_msix_addr5 = 64'hbeef_0000 + 'h50;
	force tb_top.DUT.pcie_wrapper.genblk1[3].msix_csr.cr2out_msix_addr6 = 64'hbeef_0000 + 'h60;

	force tb_top.DUT.pcie_wrapper.genblk1[3].msix_csr.cr2out_msix_ctldat0[31:0] = 32'hdead_0000;
	force tb_top.DUT.pcie_wrapper.genblk1[3].msix_csr.cr2out_msix_ctldat1[31:0] = 32'hdead_0000+'h10;
	force tb_top.DUT.pcie_wrapper.genblk1[3].msix_csr.cr2out_msix_ctldat2[31:0] = 32'hdead_0000+'h20;
	force tb_top.DUT.pcie_wrapper.genblk1[3].msix_csr.cr2out_msix_ctldat3[31:0] = 32'hdead_0000+'h30;
	force tb_top.DUT.pcie_wrapper.genblk1[3].msix_csr.cr2out_msix_ctldat4[31:0] = 32'hdead_0000+'h40;
	force tb_top.DUT.pcie_wrapper.genblk1[3].msix_csr.cr2out_msix_ctldat5[31:0] = 32'hdead_0000+'h50;
	force tb_top.DUT.pcie_wrapper.genblk1[3].msix_csr.cr2out_msix_ctldat6[31:0] = 32'hdead_0000+'h60;
    endtask : program_msix_table

    virtual task inj_err();
        bit [63:0] rdata;
	uvm_status_e status;
	tb_env0.hemem_regs.CTL.write(status, 1);	
	tb_env0.hemem_regs.INTERRUPT0.read(status, rdata[31:0]);
	// program vector num
	rdata[31:16] = vec_num;
	tb_env0.hemem_regs.INTERRUPT0.write(status, rdata[31:0]);
	tb_env0.hemem_regs.CFG.read(status, rdata);
	rdata[29] = 1;
	tb_env0.hemem_regs.CFG.write(status, rdata);
    endtask : inj_err

    virtual task check_pba();
	
	if(!tb_top.DUT.pcie_wrapper.genblk1[3].msix_csr.cr2out_msix_pba[vec_num])
	    `uvm_error(get_name(), $psprintf("PBA bit is not asserted!"))
    endtask : check_pba

    virtual task clear_mask();
	force tb_top.DUT.pcie_wrapper.genblk1[3].msix_csr.cr2out_msix_ctldat0[63:32] = 32'h0;
	force tb_top.DUT.pcie_wrapper.genblk1[3].msix_csr.cr2out_msix_ctldat1[63:32] = 32'h0;
	force tb_top.DUT.pcie_wrapper.genblk1[3].msix_csr.cr2out_msix_ctldat2[63:32] = 32'h0;
	force tb_top.DUT.pcie_wrapper.genblk1[3].msix_csr.cr2out_msix_ctldat3[63:32] = 32'h0;
	force tb_top.DUT.pcie_wrapper.genblk1[3].msix_csr.cr2out_msix_ctldat4[63:32] = 32'h0;
	force tb_top.DUT.pcie_wrapper.genblk1[3].msix_csr.cr2out_msix_ctldat5[63:32] = 32'h0;
	force tb_top.DUT.pcie_wrapper.genblk1[3].msix_csr.cr2out_msix_ctldat6[63:32] = 32'h0;
    endtask : clear_mask

   
   virtual task check_wr_data(bit [63:0] addr, bit [31:0] exp_data);
    bit [31:0] host_intr_rdata[16];
    bit[63:0]    addr;
    host_mem_read( .addr_(addr) , .data_(host_intr_rdata) , .len('d16) );
    if(changeEndian(host_intr_rdata[0]) !== exp_data)
              `uvm_error(get_name(), $psprintf("Interrupt write data mismatch exp = %0h act = %0h", exp_data, changeEndian(host_intr_rdata[0])))
   endtask : check_wr_data


endclass : hemem_intr_seq

`endif // HEMEM_INTR_SEQ_SVH
